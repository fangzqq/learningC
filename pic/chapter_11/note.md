# 位运算

- 按位与运算符
- 按位或运算符
- 按位异或运算符
- 二进制求补运算符
- 左移运算符
- 右移运算符
- 位段

## 二进制补码表示

最左边的位表示符号位， 1 表示负数，0 表示正数。

将十进制负数转换为补码表示：

- 向数值加 1
- 将绝对值表示为二进制
- 对所有位求补

## 位运算符

可以对任意类型的整数值执行位运算。

按位与经常用于掩码操作，可以轻松地将一个数据项的特定位设为 0.

按位或运算用于将一个字的某些指定位设定为 1.

任何一个值与其自己求异或时，得出的结果都为 0.

与，或，异或运算符的优先级都低于所有算术或关系运算符，但高于逻辑与，逻辑或运算符。
按位与的优先级高于按位异或，后者又高于按位或。
一元二进制求补运算符的优先级高于所有一元运算符。

## 左移与右移运算符

右移有两种情况：

- 算术右移
- 逻辑右移

对于有符号数的右移操作会实施算术右移还是逻辑右移，取决于具体的计算机系统。

若对一个数值进行左移或右移的位数大于或等于数据项的位数，将不会给出一个确定的结果。
若将一个数值移动一个负的量，结果也是不确定的。

## 位段

```c
struct packed_struct
{
    unsigned int :3;
    unsigned int f1:1;
    unsigned int f2:1;
    unsigned int f3:1;
    unsigned int type:8;
    unsigned int index:18;
};
```

注意：不能保证字段在内部是自左向右分配，还是自右向左分配。

可以在包含位段的结构体中包含普通数据类型。

关于位段的几点说明：

- 只能被声明为整数类型或 `_Bool` 类型
- 在声明中应当明确 `signed int` 或 `unsigned int`
- 位段不能具有维度，不能使用位段数组
- 不能获取位段的地址，因此不存在“指向位段的指针“
- 当字段出现在结构体定义中时，会被打包为单元，大多数情况下是一个字
- 长度为 0 的未命名字段，可以将结构体的下一个字段强制对准到单元边界的起始位置
